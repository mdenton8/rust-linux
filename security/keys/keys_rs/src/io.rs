use core;

use os;
use c_types;

#[macro_export]
macro_rules! c_str {
	($arg:expr) => (concat!($arg, '\x00'))
}

#[macro_export]
macro_rules! print {
	// Static (zero-allocation) implementation that uses compile-time `concat!()` only
	($fmt:expr) => ({
		let msg = c_str!($fmt);
		let ptr = msg.as_ptr() as *const c_types::c_char; 
		unsafe {
			os::printk(ptr);
		}
	});
	
	// Dynamic implementation that processes format arguments
	($fmt:expr, $($arg:tt)*) => ({
		use ::core::fmt::Write;
		use KernelDebugWriter;
		
		let mut writer = KernelDebugWriter {};
		writer.write_fmt(format_args!($fmt, $($arg)*)).unwrap();
	});
}

#[macro_export] 
macro_rules! println {
	($fmt:expr)              => (print!(concat!($fmt, "\n")));
	($fmt:expr, $($arg:tt)+) => (print!(concat!($fmt, "\n"), $($arg)*));
}

/// Empty structure that uses libcore's `fmt::Write` trait to provide support for writing formatted
/// Arguments lists (as generated by the built-in `format_args!()` macro`)
pub struct KernelDebugWriter {}
impl core::fmt::Write for KernelDebugWriter {
	fn write_str(&mut self, message: &str) -> core::fmt::Result {
		unsafe {
			let ptr = os::__kmalloc((message.len() + 1) as c_types::c_size_t, 0x90) as *mut c_types::c_char; // 0x90 = GFP_KERNEL
			if ptr.is_null() {
				let msg = c_str!("Failed to allocate memory for dynamic printk()\n");
				let ptr = msg.as_ptr() as *const c_types::c_char;
				os::printk(ptr);
			} else {
				core::ptr::copy(message.as_ptr(), ptr as *mut u8, message.len());
				core::ptr::write(ptr.offset(message.len() as isize), 0);
				os::printk(ptr);
				os::kfree(ptr as *const c_types::c_void);
			}
		}
		
		core::result::Result::Ok(())
	}
}